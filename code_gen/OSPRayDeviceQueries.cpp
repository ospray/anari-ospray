// Copyright 2024 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <anari/anari.h>
#include <math.h>
#include <stdint.h>
namespace anari_ospray {
static int subtype_hash(const char *str)
{
  static const uint32_t table[] = {0x7a6f0012u,
      0x6a65002bu,
      0x0u,
      0x0u,
      0x0u,
      0x65640047u,
      0x746d004bu,
      0x0u,
      0x0u,
      0x0u,
      0x62610064u,
      0x0u,
      0x73720069u,
      0x70610075u,
      0x767500a9u,
      0x6a6900adu,
      0x756300b1u,
      0x737200e6u,
      0x6f6e001du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720020u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0024u,
      0x6665001eu,
      0x100001fu,
      0x80000000u,
      0x77760021u,
      0x66650022u,
      0x1000023u,
      0x80000001u,
      0x6a690025u,
      0x6f6e0026u,
      0x65640027u,
      0x66650028u,
      0x73720029u,
      0x100002au,
      0x80000002u,
      0x67620030u,
      0x0u,
      0x0u,
      0x0u,
      0x7372003du,
      0x76750035u,
      0x0u,
      0x0u,
      0x0u,
      0x62610038u,
      0x68670036u,
      0x1000037u,
      0x80000003u,
      0x76750039u,
      0x6d6c003au,
      0x7574003bu,
      0x100003cu,
      0x80000004u,
      0x6665003eu,
      0x6463003fu,
      0x75740040u,
      0x6a690041u,
      0x706f0042u,
      0x6f6e0043u,
      0x62610044u,
      0x6d6c0045u,
      0x1000046u,
      0x80000005u,
      0x73720048u,
      0x6a690049u,
      0x100004au,
      0x80000006u,
      0x62610052u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f005bu,
      0x68670053u,
      0x66650054u,
      0x33310055u,
      0x45440057u,
      0x45440059u,
      0x1000058u,
      0x80000007u,
      0x100005au,
      0x80000008u,
      0x7473005cu,
      0x7675005du,
      0x7372005eu,
      0x6766005fu,
      0x62610060u,
      0x64630061u,
      0x66650062u,
      0x1000063u,
      0x80000009u,
      0x75740065u,
      0x75740066u,
      0x66650067u,
      0x1000068u,
      0x8000000au,
      0x7574006au,
      0x6968006bu,
      0x706f006cu,
      0x6867006du,
      0x7372006eu,
      0x6261006fu,
      0x71700070u,
      0x69680071u,
      0x6a690072u,
      0x64630073u,
      0x1000074u,
      0x8000000bu,
      0x75740084u,
      0x0u,
      0x0u,
      0x0u,
      0x7372008du,
      0x0u,
      0x0u,
      0x7a790097u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6900a5u,
      0x69680085u,
      0x75740086u,
      0x73720087u,
      0x62610088u,
      0x64630089u,
      0x6665008au,
      0x7372008bu,
      0x100008cu,
      0x8000000cu,
      0x7473008eu,
      0x7170008fu,
      0x66650090u,
      0x64630091u,
      0x75740092u,
      0x6a690093u,
      0x77760094u,
      0x66650095u,
      0x1000096u,
      0x8000000du,
      0x74730098u,
      0x6a690099u,
      0x6463009au,
      0x6261009bu,
      0x6d6c009cu,
      0x6d6c009du,
      0x7a79009eu,
      0x4342009fu,
      0x626100a0u,
      0x747300a1u,
      0x666500a2u,
      0x656400a3u,
      0x10000a4u,
      0x8000000eu,
      0x6f6e00a6u,
      0x757400a7u,
      0x10000a8u,
      0x8000000fu,
      0x626100aau,
      0x656400abu,
      0x10000acu,
      0x80000010u,
      0x6f6e00aeu,
      0x686700afu,
      0x10000b0u,
      0x80000011u,
      0x6a6900c3u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706800c8u,
      0x0u,
      0x0u,
      0x0u,
      0x737200d6u,
      0x777600c4u,
      0x6a6900c5u,
      0x747300c6u,
      0x10000c7u,
      0x80000012u,
      0x666500d0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757400d4u,
      0x737200d1u,
      0x666500d2u,
      0x10000d3u,
      0x80000013u,
      0x10000d5u,
      0x80000014u,
      0x767500d7u,
      0x646300d8u,
      0x757400d9u,
      0x767500dau,
      0x737200dbu,
      0x666500dcu,
      0x656400ddu,
      0x535200deu,
      0x666500dfu,
      0x686700e0u,
      0x767500e1u,
      0x6d6c00e2u,
      0x626100e3u,
      0x737200e4u,
      0x10000e5u,
      0x80000015u,
      0x6a6100e7u,
      0x6f6e00f0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610100u,
      0x747300f1u,
      0x676600f2u,
      0x666500f3u,
      0x737200f4u,
      0x474600f5u,
      0x767500f6u,
      0x6f6e00f7u,
      0x646300f8u,
      0x757400f9u,
      0x6a6900fau,
      0x706f00fbu,
      0x6f6e00fcu,
      0x323100fdu,
      0x454400feu,
      0x10000ffu,
      0x80000016u,
      0x6f6e0101u,
      0x68670102u,
      0x6d6c0103u,
      0x66650104u,
      0x1000105u,
      0x80000017u};
  uint32_t cur = 0x75630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int param_hash(const char *str)
{
  static const uint32_t table[] = {0x756c0017u,
      0x626100d5u,
      0x70300152u,
      0x6a61021cu,
      0x6e640293u,
      0x706102aau,
      0x666502ddu,
      0x666502e5u,
      0x746d02ebu,
      0x0u,
      0x0u,
      0x6a610498u,
      0x6a610504u,
      0x7061056eu,
      0x76630588u,
      0x736905d2u,
      0x0u,
      0x7061063au,
      0x76630689u,
      0x736807adu,
      0x716e07cbu,
      0x706107dau,
      0x736f096eu,
      0x716c0020u,
      0x6362004fu,
      0x68670071u,
      0x5444007fu,
      0x0u,
      0x0u,
      0x0u,
      0x7170009eu,
      0x757400a3u,
      0x706f0025u,
      0x0u,
      0x0u,
      0x0u,
      0x69680038u,
      0x78770026u,
      0x4a490027u,
      0x6f6e0028u,
      0x77760029u,
      0x6261002au,
      0x6d6c002bu,
      0x6a69002cu,
      0x6564002du,
      0x4e4d002eu,
      0x6261002fu,
      0x75740030u,
      0x66650031u,
      0x73720032u,
      0x6a690033u,
      0x62610034u,
      0x6d6c0035u,
      0x74730036u,
      0x1000037u,
      0x80000000u,
      0x62610039u,
      0x4e43003au,
      0x76750045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f004bu,
      0x75740046u,
      0x706f0047u,
      0x67660048u,
      0x67660049u,
      0x100004au,
      0x80000001u,
      0x6564004cu,
      0x6665004du,
      0x100004eu,
      0x80000002u,
      0x6a690050u,
      0x66650051u,
      0x6f6e0052u,
      0x75740053u,
      0x53430054u,
      0x706f0064u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610069u,
      0x6d6c0065u,
      0x706f0066u,
      0x73720067u,
      0x1000068u,
      0x80000003u,
      0x6564006au,
      0x6a69006bu,
      0x6261006cu,
      0x6f6e006du,
      0x6463006eu,
      0x6665006fu,
      0x1000070u,
      0x80000004u,
      0x76750072u,
      0x6d6c0073u,
      0x62610074u,
      0x73720075u,
      0x45440076u,
      0x6a690077u,
      0x62610078u,
      0x6e6d0079u,
      0x6665007au,
      0x7574007bu,
      0x6665007cu,
      0x7372007du,
      0x100007eu,
      0x80000005u,
      0x6a69008fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610097u,
      0x74730090u,
      0x75740091u,
      0x62610092u,
      0x6f6e0093u,
      0x64630094u,
      0x66650095u,
      0x1000096u,
      0x80000006u,
      0x6e6d0098u,
      0x71700099u,
      0x6d6c009au,
      0x6665009bu,
      0x7473009cu,
      0x100009du,
      0x80000007u,
      0x6665009fu,
      0x646300a0u,
      0x757400a1u,
      0x10000a2u,
      0x80000008u,
      0x736500a4u,
      0x6f6e00b2u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6900c8u,
      0x767500b3u,
      0x626100b4u,
      0x757400b5u,
      0x6a6900b6u,
      0x706f00b7u,
      0x6f6e00b8u,
      0x454300b9u,
      0x706f00bbu,
      0x6a6900c0u,
      0x6d6c00bcu,
      0x706f00bdu,
      0x737200beu,
      0x10000bfu,
      0x80000009u,
      0x747300c1u,
      0x757400c2u,
      0x626100c3u,
      0x6f6e00c4u,
      0x646300c5u,
      0x666500c6u,
      0x10000c7u,
      0x8000000au,
      0x636200c9u,
      0x767500cau,
      0x757400cbu,
      0x666500ccu,
      0x343000cdu,
      0x10000d1u,
      0x10000d2u,
      0x10000d3u,
      0x10000d4u,
      0x8000000bu,
      0x8000000cu,
      0x8000000du,
      0x8000000eu,
      0x746300d6u,
      0x6c6b00e7u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665014bu,
      0x686700e8u,
      0x737200e9u,
      0x706f00eau,
      0x767500ebu,
      0x6f6e00ecu,
      0x656400edu,
      0x530000eeu,
      0x8000000fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650141u,
      0x67660142u,
      0x73720143u,
      0x62610144u,
      0x64630145u,
      0x75740146u,
      0x6a690147u,
      0x706f0148u,
      0x6f6e0149u,
      0x100014au,
      0x80000010u,
      0x4443014cu,
      0x706f014du,
      0x6d6c014eu,
      0x706f014fu,
      0x73720150u,
      0x1000151u,
      0x80000011u,
      0x1000192u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x716d0193u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6261019du,
      0x0u,
      0x0u,
      0x0u,
      0x666501afu,
      0x0u,
      0x0u,
      0x6d6c0218u,
      0x80000012u,
      0x66650197u,
      0x0u,
      0x0u,
      0x7473019bu,
      0x73720198u,
      0x62610199u,
      0x100019au,
      0x80000013u,
      0x100019cu,
      0x80000014u,
      0x6f6e019eu,
      0x6f6e019fu,
      0x666501a0u,
      0x6d6c01a1u,
      0x2f2e01a2u,
      0x656301a3u,
      0x706f01a5u,
      0x666501aau,
      0x6d6c01a6u,
      0x706f01a7u,
      0x737201a8u,
      0x10001a9u,
      0x80000015u,
      0x717001abu,
      0x757401acu,
      0x696801adu,
      0x10001aeu,
      0x80000016u,
      0x626101b0u,
      0x737201b1u,
      0x646301b2u,
      0x706f01b3u,
      0x626101b4u,
      0x757401b5u,
      0x530001b6u,
      0x80000017u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0209u,
      0x0u,
      0x0u,
      0x0u,
      0x706f020fu,
      0x7372020au,
      0x6e6d020bu,
      0x6261020cu,
      0x6d6c020du,
      0x100020eu,
      0x80000018u,
      0x76750210u,
      0x68670211u,
      0x69680212u,
      0x6f6e0213u,
      0x66650214u,
      0x74730215u,
      0x74730216u,
      0x1000217u,
      0x80000019u,
      0x706f0219u,
      0x7372021au,
      0x100021bu,
      0x8000001au,
      0x75740225u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0228u,
      0x0u,
      0x0u,
      0x0u,
      0x7372028bu,
      0x62610226u,
      0x1000227u,
      0x8000001bu,
      0x706f0229u,
      0x6a69022au,
      0x7473022bu,
      0x6665022cu,
      0x5200022du,
      0x8000001cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c027fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x76750284u,
      0x71700280u,
      0x69680281u,
      0x62610282u,
      0x1000283u,
      0x8000001du,
      0x62610285u,
      0x6d6c0286u,
      0x6a690287u,
      0x75740288u,
      0x7a790289u,
      0x100028au,
      0x8000001eu,
      0x6665028cu,
      0x6463028du,
      0x7574028eu,
      0x6a69028fu,
      0x706f0290u,
      0x6f6e0291u,
      0x1000292u,
      0x8000001fu,
      0x6867029du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6902a3u,
      0x6665029eu,
      0x3331029fu,
      0x10002a1u,
      0x10002a2u,
      0x80000020u,
      0x80000021u,
      0x747302a4u,
      0x747302a5u,
      0x6a6902a6u,
      0x777602a7u,
      0x666502a8u,
      0x10002a9u,
      0x80000022u,
      0x736c02b9u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6502cbu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x777602dau,
      0x6d6c02c0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x10002cau,
      0x706f02c1u,
      0x676602c2u,
      0x676602c3u,
      0x424102c4u,
      0x6f6e02c5u,
      0x686702c6u,
      0x6d6c02c7u,
      0x666502c8u,
      0x10002c9u,
      0x80000023u,
      0x80000024u,
      0x6d6c02d3u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757402d6u,
      0x656402d4u,
      0x10002d5u,
      0x80000025u,
      0x666502d7u,
      0x737202d8u,
      0x10002d9u,
      0x80000026u,
      0x7a7902dbu,
      0x10002dcu,
      0x80000027u,
      0x706f02deu,
      0x6e6d02dfu,
      0x666502e0u,
      0x757402e1u,
      0x737202e2u,
      0x7a7902e3u,
      0x10002e4u,
      0x80000028u,
      0x6a6902e6u,
      0x686702e7u,
      0x696802e8u,
      0x757402e9u,
      0x10002eau,
      0x80000029u,
      0x626102f2u,
      0x7741034eu,
      0x73720414u,
      0x0u,
      0x0u,
      0x73690416u,
      0x706f0491u,
      0x686702f3u,
      0x666502f4u,
      0x530002f5u,
      0x8000002au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x66650348u,
      0x68670349u,
      0x6a69034au,
      0x706f034bu,
      0x6f6e034cu,
      0x100034du,
      0x8000002bu,
      0x75740384u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6766038du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720393u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665039cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x757403a5u,
      0x666503abu,
      0x0u,
      0x62610402u,
      0x75740385u,
      0x73720386u,
      0x6a690387u,
      0x63620388u,
      0x76750389u,
      0x7574038au,
      0x6665038bu,
      0x100038cu,
      0x8000002cu,
      0x6766038eu,
      0x7473038fu,
      0x66650390u,
      0x75740391u,
      0x1000392u,
      0x8000002du,
      0x62610394u,
      0x6f6e0395u,
      0x74730396u,
      0x67660397u,
      0x706f0398u,
      0x73720399u,
      0x6e6d039au,
      0x100039bu,
      0x8000002eu,
      0x7372039du,
      0x5352039eu,
      0x6261039fu,
      0x656403a0u,
      0x6a6903a1u,
      0x767503a2u,
      0x747303a3u,
      0x10003a4u,
      0x8000002fu,
      0x626103a6u,
      0x6f6e03a7u,
      0x646303a8u,
      0x666503a9u,
      0x10003aau,
      0x80000030u,
      0x6f6e03acu,
      0x747303adu,
      0x6a6903aeu,
      0x757403afu,
      0x7a7903b0u,
      0x450003b1u,
      0x80000031u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a6903f6u,
      0x747303f7u,
      0x757403f8u,
      0x737203f9u,
      0x6a6903fau,
      0x636203fbu,
      0x767503fcu,
      0x757403fdu,
      0x6a6903feu,
      0x706f03ffu,
      0x6f6e0400u,
      0x1000401u,
      0x80000032u,
      0x6d6c0403u,
      0x6a690404u,
      0x65640405u,
      0x4e4d0406u,
      0x62610407u,
      0x75740408u,
      0x66650409u,
      0x7372040au,
      0x6a69040bu,
      0x6261040cu,
      0x6d6c040du,
      0x4443040eu,
      0x706f040fu,
      0x6d6c0410u,
      0x706f0411u,
      0x73720412u,
      0x1000413u,
      0x80000033u,
      0x1000415u,
      0x80000034u,
      0x65640420u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610489u,
      0x66650421u,
      0x74730422u,
      0x64630423u,
      0x66650424u,
      0x6f6e0425u,
      0x64630426u,
      0x66650427u,
      0x55000428u,
      0x80000035u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f047du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x69680480u,
      0x7372047eu,
      0x100047fu,
      0x80000036u,
      0x6a690481u,
      0x64630482u,
      0x6c6b0483u,
      0x6f6e0484u,
      0x66650485u,
      0x74730486u,
      0x74730487u,
      0x1000488u,
      0x80000037u,
      0x6564048au,
      0x6a69048bu,
      0x6261048cu,
      0x6f6e048du,
      0x6463048eu,
      0x6665048fu,
      0x1000490u,
      0x80000038u,
      0x77760492u,
      0x62610493u,
      0x6d6c0494u,
      0x76750495u,
      0x66650496u,
      0x1000497u,
      0x80000039u,
      0x7a7904a1u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x686704a6u,
      0x706f04a2u,
      0x767504a3u,
      0x757404a4u,
      0x10004a5u,
      0x8000003au,
      0x696804a7u,
      0x757404a8u,
      0x540004a9u,
      0x8000003bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626104fdu,
      0x6e6d04feu,
      0x717004ffu,
      0x6d6c0500u,
      0x66650501u,
      0x74730502u,
      0x1000503u,
      0x8000003cu,
      0x7974050du,
      0x0u,
      0x0u,
      0x0u,
      0x7574054fu,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0560u,
      0x66650512u,
      0x0u,
      0x0u,
      0x0u,
      0x54430518u,
      0x73720513u,
      0x6a690514u,
      0x62610515u,
      0x6d6c0516u,
      0x1000517u,
      0x8000003du,
      0x706f0529u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610535u,
      0x0u,
      0x0u,
      0x6463053fu,
      0x6f6e052au,
      0x7574052bu,
      0x7372052cu,
      0x6a69052du,
      0x6362052eu,
      0x7675052fu,
      0x75740530u,
      0x6a690531u,
      0x706f0532u,
      0x6f6e0533u,
      0x1000534u,
      0x8000003eu,
      0x75740536u,
      0x69680537u,
      0x4d4c0538u,
      0x66650539u,
      0x6f6e053au,
      0x6867053bu,
      0x7574053cu,
      0x6968053du,
      0x100053eu,
      0x8000003fu,
      0x62610540u,
      0x75740541u,
      0x75740542u,
      0x66650543u,
      0x73720544u,
      0x6a690545u,
      0x6f6e0546u,
      0x68670547u,
      0x46450548u,
      0x77760549u,
      0x6665054au,
      0x6f6e054bu,
      0x7574054cu,
      0x7473054du,
      0x100054eu,
      0x80000040u,
      0x69610550u,
      0x6d6c0558u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f055du,
      0x6d6c0559u,
      0x6a69055au,
      0x6463055bu,
      0x100055cu,
      0x80000041u,
      0x6564055eu,
      0x100055fu,
      0x80000042u,
      0x44430561u,
      0x706f0562u,
      0x6f6e0563u,
      0x75740564u,
      0x73720565u,
      0x6a690566u,
      0x63620567u,
      0x76750568u,
      0x75740569u,
      0x6a69056au,
      0x706f056bu,
      0x6f6e056cu,
      0x100056du,
      0x80000043u,
      0x6e6d057du,
      0x0u,
      0x0u,
      0x0u,
      0x62610580u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x73720583u,
      0x6665057eu,
      0x100057fu,
      0x80000044u,
      0x73720581u,
      0x1000582u,
      0x80000045u,
      0x6e6d0584u,
      0x62610585u,
      0x6d6c0586u,
      0x1000587u,
      0x80000046u,
      0x6463059bu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666105a3u,
      0x0u,
      0x6a6905b7u,
      0x0u,
      0x0u,
      0x757405bcu,
      0x6d6c059cu,
      0x7675059du,
      0x7473059eu,
      0x6a69059fu,
      0x706f05a0u,
      0x6f6e05a1u,
      0x10005a2u,
      0x80000047u,
      0x646305a8u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e05adu,
      0x6a6905a9u,
      0x757405aau,
      0x7a7905abu,
      0x10005acu,
      0x80000048u,
      0x6a6905aeu,
      0x6f6e05afu,
      0x686705b0u,
      0x424105b1u,
      0x6f6e05b2u,
      0x686705b3u,
      0x6d6c05b4u,
      0x666505b5u,
      0x10005b6u,
      0x80000049u,
      0x686705b8u,
      0x6a6905b9u,
      0x6f6e05bau,
      0x10005bbu,
      0x8000004au,
      0x554f05bdu,
      0x676605c3u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x737205c9u,
      0x676605c4u,
      0x747305c5u,
      0x666505c6u,
      0x757405c7u,
      0x10005c8u,
      0x8000004bu,
      0x626105cau,
      0x6f6e05cbu,
      0x747305ccu,
      0x676605cdu,
      0x706f05ceu,
      0x737205cfu,
      0x6e6d05d0u,
      0x10005d1u,
      0x8000004cu,
      0x797805dcu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x787305e7u,
      0x0u,
      0x0u,
      0x6a6905f5u,
      0x666505ddu,
      0x6d6c05deu,
      0x545305dfu,
      0x626105e0u,
      0x6e6d05e1u,
      0x717005e2u,
      0x6d6c05e3u,
      0x666505e4u,
      0x747305e5u,
      0x10005e6u,
      0x8000004du,
      0x6a6905ecu,
      0x0u,
      0x0u,
      0x0u,
      0x666505f2u,
      0x757405edu,
      0x6a6905eeu,
      0x706f05efu,
      0x6f6e05f0u,
      0x10005f1u,
      0x8000004eu,
      0x737205f3u,
      0x10005f4u,
      0x8000004fu,
      0x6e6d05f6u,
      0x6a6905f7u,
      0x757405f8u,
      0x6a6905f9u,
      0x777605fau,
      0x666505fbu,
      0x2f2e05fcu,
      0x736105fdu,
      0x7574060fu,
      0x0u,
      0x706f061fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f640624u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610634u,
      0x75740610u,
      0x73720611u,
      0x6a690612u,
      0x63620613u,
      0x76750614u,
      0x75740615u,
      0x66650616u,
      0x34300617u,
      0x100061bu,
      0x100061cu,
      0x100061du,
      0x100061eu,
      0x80000050u,
      0x80000051u,
      0x80000052u,
      0x80000053u,
      0x6d6c0620u,
      0x706f0621u,
      0x73720622u,
      0x1000623u,
      0x80000054u,
      0x100062fu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x65640630u,
      0x80000055u,
      0x66650631u,
      0x79780632u,
      0x1000633u,
      0x80000056u,
      0x65640635u,
      0x6a690636u,
      0x76750637u,
      0x74730638u,
      0x1000639u,
      0x80000057u,
      0x65640649u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0666u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7675066du,
      0x6a69064au,
      0x7661064bu,
      0x6f6e0660u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x74730664u,
      0x64630661u,
      0x66650662u,
      0x1000663u,
      0x80000058u,
      0x1000665u,
      0x80000059u,
      0x65640667u,
      0x66650668u,
      0x73720669u,
      0x6665066au,
      0x7372066bu,
      0x100066cu,
      0x8000005au,
      0x6d67066eu,
      0x69680674u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6665067au,
      0x6f6e0675u,
      0x66650676u,
      0x74730677u,
      0x74730678u,
      0x1000679u,
      0x8000005bu,
      0x7574067bu,
      0x7574067cu,
      0x6665067du,
      0x5150067eu,
      0x6261067fu,
      0x75740680u,
      0x69680681u,
      0x4d4c0682u,
      0x66650683u,
      0x6f6e0684u,
      0x68670685u,
      0x75740686u,
      0x69680687u,
      0x1000688u,
      0x8000005cu,
      0x6261069cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666106a0u,
      0x7b6406cau,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666106e5u,
      0x0u,
      0x0u,
      0x0u,
      0x6261073du,
      0x737207a7u,
      0x6d6c069du,
      0x6665069eu,
      0x100069fu,
      0x8000005du,
      0x656406a5u,
      0x0u,
      0x0u,
      0x0u,
      0x666506aau,
      0x706f06a6u,
      0x787706a7u,
      0x747306a8u,
      0x10006a9u,
      0x8000005eu,
      0x6f6e06abu,
      0x534306acu,
      0x706f06bcu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f06c1u,
      0x6d6c06bdu,
      0x706f06beu,
      0x737206bfu,
      0x10006c0u,
      0x8000005fu,
      0x767506c2u,
      0x686706c3u,
      0x696806c4u,
      0x6f6e06c5u,
      0x666506c6u,
      0x747306c7u,
      0x747306c8u,
      0x10006c9u,
      0x80000060u,
      0x666506e1u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x666506e3u,
      0x10006e2u,
      0x80000061u,
      0x10006e4u,
      0x80000062u,
      0x646306eau,
      0x0u,
      0x0u,
      0x0u,
      0x646306efu,
      0x6a6906ebu,
      0x6f6e06ecu,
      0x686706edu,
      0x10006eeu,
      0x80000063u,
      0x767506f0u,
      0x6d6c06f1u,
      0x626106f2u,
      0x737206f3u,
      0x440006f4u,
      0x80000064u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0738u,
      0x6d6c0739u,
      0x706f073au,
      0x7372073bu,
      0x100073cu,
      0x80000065u,
      0x7574073eu,
      0x7675073fu,
      0x74730740u,
      0x44430741u,
      0x62610742u,
      0x6d6c0743u,
      0x6d6c0744u,
      0x63620745u,
      0x62610746u,
      0x64630747u,
      0x6c6b0748u,
      0x56000749u,
      0x80000066u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7473079fu,
      0x666507a0u,
      0x737207a1u,
      0x454407a2u,
      0x626107a3u,
      0x757407a4u,
      0x626107a5u,
      0x10007a6u,
      0x80000067u,
      0x676607a8u,
      0x626107a9u,
      0x646307aau,
      0x666507abu,
      0x10007acu,
      0x80000068u,
      0x6a6907b8u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x626107c0u,
      0x646307b9u,
      0x6c6b07bau,
      0x6f6e07bbu,
      0x666507bcu,
      0x747307bdu,
      0x747307beu,
      0x10007bfu,
      0x80000069u,
      0x6f6e07c1u,
      0x747307c2u,
      0x6e6d07c3u,
      0x6a6907c4u,
      0x747307c5u,
      0x747307c6u,
      0x6a6907c7u,
      0x706f07c8u,
      0x6f6e07c9u,
      0x10007cau,
      0x8000006au,
      0x6a6907ceu,
      0x0u,
      0x10007d9u,
      0x757407cfu,
      0x454407d0u,
      0x6a6907d1u,
      0x747307d2u,
      0x757407d3u,
      0x626107d4u,
      0x6f6e07d5u,
      0x646307d6u,
      0x666507d7u,
      0x10007d8u,
      0x8000006bu,
      0x8000006cu,
      0x736c07e9u,
      0x0u,
      0x0u,
      0x0u,
      0x73720859u,
      0x0u,
      0x0u,
      0x0u,
      0x747308b2u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c090au,
      0x767507f0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a69084au,
      0x666507f1u,
      0x530007f2u,
      0x8000006du,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610845u,
      0x6f6e0846u,
      0x68670847u,
      0x66650848u,
      0x1000849u,
      0x8000006eu,
      0x6261084bu,
      0x6f6e084cu,
      0x6463084du,
      0x6665084eu,
      0x5554084fu,
      0x69680850u,
      0x73720851u,
      0x66650852u,
      0x74730853u,
      0x69680854u,
      0x706f0855u,
      0x6d6c0856u,
      0x65640857u,
      0x1000858u,
      0x8000006fu,
      0x7574085au,
      0x6665085bu,
      0x7978085cu,
      0x2f2e085du,
      0x7561085eu,
      0x75740872u,
      0x0u,
      0x70610882u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x706f0897u,
      0x0u,
      0x706f089du,
      0x0u,
      0x626108a5u,
      0x0u,
      0x626108abu,
      0x75740873u,
      0x73720874u,
      0x6a690875u,
      0x63620876u,
      0x76750877u,
      0x75740878u,
      0x66650879u,
      0x3430087au,
      0x100087eu,
      0x100087fu,
      0x1000880u,
      0x1000881u,
      0x80000070u,
      0x80000071u,
      0x80000072u,
      0x80000073u,
      0x71700891u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6d6c0893u,
      0x1000892u,
      0x80000074u,
      0x706f0894u,
      0x73720895u,
      0x1000896u,
      0x80000075u,
      0x73720898u,
      0x6e6d0899u,
      0x6261089au,
      0x6d6c089bu,
      0x100089cu,
      0x80000076u,
      0x7473089eu,
      0x6a69089fu,
      0x757408a0u,
      0x6a6908a1u,
      0x706f08a2u,
      0x6f6e08a3u,
      0x10008a4u,
      0x80000077u,
      0x656408a6u,
      0x6a6908a7u,
      0x767508a8u,
      0x747308a9u,
      0x10008aau,
      0x80000078u,
      0x6f6e08acu,
      0x686708adu,
      0x666508aeu,
      0x6f6e08afu,
      0x757408b0u,
      0x10008b1u,
      0x80000079u,
      0x6a6908b3u,
      0x636208b4u,
      0x6d6c08b5u,
      0x666508b6u,
      0x4d0008b7u,
      0x8000007au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a690904u,
      0x68670905u,
      0x69680906u,
      0x75740907u,
      0x74730908u,
      0x1000909u,
      0x8000007bu,
      0x7675090bu,
      0x6e6d090cu,
      0x6665090du,
      0x5400090eu,
      0x8000007cu,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x62610962u,
      0x6e6d0963u,
      0x71700964u,
      0x6d6c0965u,
      0x6a690966u,
      0x6f6e0967u,
      0x68670968u,
      0x53520969u,
      0x6261096au,
      0x7574096bu,
      0x6665096cu,
      0x100096du,
      0x8000007du,
      0x73720972u,
      0x0u,
      0x0u,
      0x62610976u,
      0x6d6c0973u,
      0x65640974u,
      0x1000975u,
      0x8000007eu,
      0x71700977u,
      0x4e4d0978u,
      0x706f0979u,
      0x6564097au,
      0x6665097bu,
      0x3331097cu,
      0x100097eu,
      0x100097fu,
      0x8000007fu,
      0x80000080u};
  uint32_t cur = 0x78610000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static int info_hash(const char *str)
{
  static const uint32_t table[] = {0x69680014u,
      0x6665001bu,
      0x796c0038u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6a610057u,
      0x0u,
      0x0u,
      0x6261006cu,
      0x0u,
      0x66650075u,
      0x706f007du,
      0x0u,
      0x7473008cu,
      0x6261008fu,
      0x62610015u,
      0x6f6e0016u,
      0x6f6e0017u,
      0x66650018u,
      0x6d6c0019u,
      0x100001au,
      0x8000000au,
      0x7466001cu,
      0x6261002au,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6463002fu,
      0x7675002bu,
      0x6d6c002cu,
      0x7574002du,
      0x100002eu,
      0x80000001u,
      0x73720030u,
      0x6a690031u,
      0x71700032u,
      0x75740033u,
      0x6a690034u,
      0x706f0035u,
      0x6f6e0036u,
      0x1000037u,
      0x80000004u,
      0x66650045u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x7574004fu,
      0x6e6d0046u,
      0x66650047u,
      0x6f6e0048u,
      0x75740049u,
      0x5554004au,
      0x7a79004bu,
      0x7170004cu,
      0x6665004du,
      0x100004eu,
      0x80000005u,
      0x66650050u,
      0x6f6e0051u,
      0x74730052u,
      0x6a690053u,
      0x706f0054u,
      0x6f6e0055u,
      0x1000056u,
      0x80000008u,
      0x79780060u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x0u,
      0x6f6e0066u,
      0x6a690061u,
      0x6e6d0062u,
      0x76750063u,
      0x6e6d0064u,
      0x1000065u,
      0x80000003u,
      0x6a690067u,
      0x6e6d0068u,
      0x76750069u,
      0x6e6d006au,
      0x100006bu,
      0x80000002u,
      0x7372006du,
      0x6261006eu,
      0x6e6d006fu,
      0x66650070u,
      0x75740071u,
      0x66650072u,
      0x73720073u,
      0x1000074u,
      0x80000009u,
      0x72710076u,
      0x76750077u,
      0x6a690078u,
      0x73720079u,
      0x6665007au,
      0x6564007bu,
      0x100007cu,
      0x80000000u,
      0x7675007eu,
      0x7372007fu,
      0x64630080u,
      0x66650081u,
      0x46450082u,
      0x79780083u,
      0x75740084u,
      0x66650085u,
      0x6f6e0086u,
      0x74730087u,
      0x6a690088u,
      0x706f0089u,
      0x6f6e008au,
      0x100008bu,
      0x80000007u,
      0x6665008du,
      0x100008eu,
      0x8000000bu,
      0x6d6c0090u,
      0x76750091u,
      0x66650092u,
      0x1000093u,
      0x80000006u};
  uint32_t cur = 0x77630000u;
  for (int i = 0; cur != 0; ++i) {
    uint32_t idx = cur & 0xFFFFu;
    uint32_t low = (cur >> 16u) & 0xFFu;
    uint32_t high = (cur >> 24u) & 0xFFu;
    uint32_t c = (uint32_t)str[i];
    if (c >= low && c < high) {
      cur = table[idx + c - low];
    } else {
      break;
    }
    if (cur & 0x80000000u) {
      return cur & 0xFFFFu;
    }
    if (str[i] == 0) {
      break;
    }
  }
  return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char **query_extensions()
{
  static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_RING",
      "ANARI_KHR_LIGHT_QUAD",
      "ANARI_KHR_LIGHT_HDRI",
      "ANARI_OSPRAY_RENDERER_DEFAULT",
      "ANARI_OSPRAY_RENDERER_PATHTRACER",
      "ANARI_OSPRAY_RENDERER_SCIVIS",
      "ANARI_OSPRAY_RENDERER_DEBUG",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_ISOSURFACE",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_AREA_LIGHTS",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
      "ANARI_OSPRAY_EXTENSIONS",
      0};
  return extensions;
}
const char **query_object_types(ANARIDataType type)
{
  switch (type) {
  case ANARI_LIGHT: {
    static const char *ANARI_LIGHT_subtypes[] = {
        "directional", "point", "ring", "quad", "hdri", "spot", 0};
    return ANARI_LIGHT_subtypes;
  }
  case ANARI_RENDERER: {
    static const char *ANARI_RENDERER_subtypes[] = {
        "default", "pathtracer", "scivis", "debug", 0};
    return ANARI_RENDERER_subtypes;
  }
  case ANARI_CAMERA: {
    static const char *ANARI_CAMERA_subtypes[] = {
        "orthographic", "perspective", 0};
    return ANARI_CAMERA_subtypes;
  }
  case ANARI_GEOMETRY: {
    static const char *ANARI_GEOMETRY_subtypes[] = {"cone",
        "curve",
        "cylinder",
        "isosurface",
        "quad",
        "sphere",
        "triangle",
        0};
    return ANARI_GEOMETRY_subtypes;
  }
  case ANARI_MATERIAL: {
    static const char *ANARI_MATERIAL_subtypes[] = {
        "matte", "physicallyBased", 0};
    return ANARI_MATERIAL_subtypes;
  }
  case ANARI_SAMPLER: {
    static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", 0};
    return ANARI_SAMPLER_subtypes;
  }
  case ANARI_SPATIAL_FIELD: {
    static const char *ANARI_SPATIAL_FIELD_subtypes[] = {
        "structuredRegular", 0};
    return ANARI_SPATIAL_FIELD_subtypes;
  }
  case ANARI_VOLUME: {
    static const char *ANARI_VOLUME_subtypes[] = {"transferFunction1D", 0};
    return ANARI_VOLUME_subtypes;
  }
  default: {
    static const char *none_subtypes[] = {0};
    return none_subtypes;
  }
  }
}
static const void *ANARI_DEVICE_allowInvalidMaterials_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "show surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_invalidMaterialColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          1.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "color to identify surfaces with invalid materials";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallback_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "callback used to report information to the application";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_statusCallbackUserData_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "optional pointer passed as the first argument of the status callback";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_DEVICE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 0:
    return ANARI_DEVICE_allowInvalidMaterials_info(
        paramType, infoName, infoType);
  case 51:
    return ANARI_DEVICE_invalidMaterialColor_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_DEVICE_name_info(paramType, infoName, infoType);
  case 102:
    return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
  case 103:
    return ANARI_DEVICE_statusCallbackUserData_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_irradiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "amount of light in W/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emission direction of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 0;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_angularDiameter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "apparent size of the light in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
  case 56:
    return ANARI_LIGHT_directional_irradiance_info(
        paramType, infoName, infoType);
  case 31:
    return ANARI_LIGHT_directional_direction_info(
        paramType, infoName, infoType);
  case 5:
    return ANARI_LIGHT_directional_angularDiameter_info(
        paramType, infoName, infoType);
  case 88:
    return ANARI_LIGHT_directional_radiance_info(paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_directional_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 1;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "radius of the sphere light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
  case 78:
    return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
  case 49:
    return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
  case 79:
    return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
  case 89:
    return ANARI_LIGHT_point_radius_info(paramType, infoName, infoType);
  case 88:
    return ANARI_LIGHT_point_radiance_info(paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_point_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis the ring is pointing at";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "outer radius of the ring";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_innerRadius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "inner radius of the ring";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_intensityDistribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "luminous intensity distribution for photometric lights";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_c0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "direction of the C0-(half)plane";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 2;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_ring_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_ring_color_info(paramType, infoName, infoType);
  case 78:
    return ANARI_LIGHT_ring_position_info(paramType, infoName, infoType);
  case 31:
    return ANARI_LIGHT_ring_direction_info(paramType, infoName, infoType);
  case 73:
    return ANARI_LIGHT_ring_openingAngle_info(paramType, infoName, infoType);
  case 35:
    return ANARI_LIGHT_ring_falloffAngle_info(paramType, infoName, infoType);
  case 49:
    return ANARI_LIGHT_ring_intensity_info(paramType, infoName, infoType);
  case 79:
    return ANARI_LIGHT_ring_power_info(paramType, infoName, infoType);
  case 89:
    return ANARI_LIGHT_ring_radius_info(paramType, infoName, infoType);
  case 47:
    return ANARI_LIGHT_ring_innerRadius_info(paramType, infoName, infoType);
  case 88:
    return ANARI_LIGHT_ring_radiance_info(paramType, infoName, infoType);
  case 50:
    return ANARI_LIGHT_ring_intensityDistribution_info(
        paramType, infoName, infoType);
  case 18:
    return ANARI_LIGHT_ring_c0_info(paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_ring_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_edge1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "vector";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vector of the first edge";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_edge2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "vector";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vector of the second edge";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_side_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "front";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "light emitting sides of the quad";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"front", "back", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_intensityDistribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "luminous intensity distribution for photometric lights";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 3;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_quad_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_quad_color_info(paramType, infoName, infoType);
  case 78:
    return ANARI_LIGHT_quad_position_info(paramType, infoName, infoType);
  case 32:
    return ANARI_LIGHT_quad_edge1_info(paramType, infoName, infoType);
  case 33:
    return ANARI_LIGHT_quad_edge2_info(paramType, infoName, infoType);
  case 49:
    return ANARI_LIGHT_quad_intensity_info(paramType, infoName, infoType);
  case 79:
    return ANARI_LIGHT_quad_power_info(paramType, infoName, infoType);
  case 88:
    return ANARI_LIGHT_quad_radiance_info(paramType, infoName, infoType);
  case 97:
    return ANARI_LIGHT_quad_side_info(paramType, infoName, infoType);
  case 50:
    return ANARI_LIGHT_quad_intensityDistribution_info(
        paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_quad_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "up direction of the light in world space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_radiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_layout_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "equirectangular";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "radiance image layout";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"equirectangular", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_scale_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "scale factor for radiance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 4;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_hdri_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_hdri_color_info(paramType, infoName, infoType);
  case 108:
    return ANARI_LIGHT_hdri_up_info(paramType, infoName, infoType);
  case 88:
    return ANARI_LIGHT_hdri_radiance_info(paramType, infoName, infoType);
  case 58:
    return ANARI_LIGHT_hdri_layout_info(paramType, infoName, infoType);
  case 93:
    return ANARI_LIGHT_hdri_scale_info(paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_hdri_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_denoise_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "enable Open Image Denoise (OIDN)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_denoiseAlpha_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether to denoise the alpha channel as well";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_denoiseQuality_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "medium";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "denoiser quality";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"low", "medium", "high", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 5;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 77:
    return ANARI_RENDERER_default_pixelSamples_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_RENDERER_default_maxPathLength_info(
        paramType, infoName, infoType);
  case 67:
    return ANARI_RENDERER_default_minContribution_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_RENDERER_default_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_default_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_default_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_default_ambientRadiance_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_default_lightSamples_info(
        paramType, infoName, infoType);
  case 92:
    return ANARI_RENDERER_default_roulettePathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_default_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 62:
    return ANARI_RENDERER_default_maxContribution_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_RENDERER_default_backgroundRefraction_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_RENDERER_default_denoise_info(paramType, infoName, infoType);
  case 29:
    return ANARI_RENDERER_default_denoiseAlpha_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_RENDERER_default_denoiseQuality_info(
        paramType, infoName, infoType);
  case 68:
    return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_lightSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(-1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of random light samples per path vertex, per default all light sources are sampled";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_roulettePathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(5)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "ray recursion depth at which to start Russian roulette termination";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum number of non-specular (i.e., diffuse and glossy) bounces";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_maxContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "samples are clamped to this value before they are accumulated into the framebuffer";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_backgroundRefraction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "allow for alpha blending even if background is seen through refractive objects like glass";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_denoise_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "enable Open Image Denoise (OIDN)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_denoiseAlpha_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether to denoise the alpha channel as well";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_denoiseQuality_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "medium";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "denoiser quality";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"low", "medium", "high", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 6;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 77:
    return ANARI_RENDERER_pathtracer_pixelSamples_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_RENDERER_pathtracer_maxPathLength_info(
        paramType, infoName, infoType);
  case 67:
    return ANARI_RENDERER_pathtracer_minContribution_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_RENDERER_pathtracer_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_pathtracer_background_info(
        paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_pathtracer_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_pathtracer_ambientRadiance_info(
        paramType, infoName, infoType);
  case 60:
    return ANARI_RENDERER_pathtracer_lightSamples_info(
        paramType, infoName, infoType);
  case 92:
    return ANARI_RENDERER_pathtracer_roulettePathLength_info(
        paramType, infoName, infoType);
  case 64:
    return ANARI_RENDERER_pathtracer_maxScatteringEvents_info(
        paramType, infoName, infoType);
  case 62:
    return ANARI_RENDERER_pathtracer_maxContribution_info(
        paramType, infoName, infoType);
  case 16:
    return ANARI_RENDERER_pathtracer_backgroundRefraction_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_RENDERER_pathtracer_denoise_info(
        paramType, infoName, infoType);
  case 29:
    return ANARI_RENDERER_pathtracer_denoiseAlpha_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_RENDERER_pathtracer_denoiseQuality_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_shadows_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "whether to compute (hard) shadows";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light color (RGB)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_ambientRadiance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "ambient light intensity";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "number of rays per sample to compute ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_aoDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {100000000000000000000.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "maximum distance to consider for ambient occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_volumeSamplingRate_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampling rate for volumes";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_visibleLights_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether light sources are potentially visible (as in the path tracer, regarding each light's visible)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_denoise_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "enable Open Image Denoise (OIDN)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_denoiseAlpha_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(0)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "whether to denoise the alpha channel as well";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_denoiseQuality_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "medium";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "denoiser quality";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"low", "medium", "high", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 7;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 77:
    return ANARI_RENDERER_scivis_pixelSamples_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_RENDERER_scivis_maxPathLength_info(
        paramType, infoName, infoType);
  case 67:
    return ANARI_RENDERER_scivis_minContribution_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_RENDERER_scivis_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_scivis_background_info(paramType, infoName, infoType);
  case 94:
    return ANARI_RENDERER_scivis_shadows_info(paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_scivis_ambientColor_info(
        paramType, infoName, infoType);
  case 4:
    return ANARI_RENDERER_scivis_ambientRadiance_info(
        paramType, infoName, infoType);
  case 7:
    return ANARI_RENDERER_scivis_aoSamples_info(paramType, infoName, infoType);
  case 6:
    return ANARI_RENDERER_scivis_aoDistance_info(paramType, infoName, infoType);
  case 125:
    return ANARI_RENDERER_scivis_volumeSamplingRate_info(
        paramType, infoName, infoType);
  case 123:
    return ANARI_RENDERER_scivis_visibleLights_info(
        paramType, infoName, infoType);
  case 28:
    return ANARI_RENDERER_scivis_denoise_info(paramType, infoName, infoType);
  case 29:
    return ANARI_RENDERER_scivis_denoiseAlpha_info(
        paramType, infoName, infoType);
  case 30:
    return ANARI_RENDERER_scivis_denoiseQuality_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_method_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "which debugging method to use";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"eyeLight",
          "rayDir",
          "Ng",
          "Ns",
          "color",
          "texCoord",
          "backfacing_Ng",
          "backfacing_Ns",
          "dPds",
          "dPdt",
          "primID",
          "geomID",
          "instID",
          "volume",
          "rayDir",
          "testFrame",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_pixelSamples_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "samples per pixel";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_maxPathLength_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_INT32 && infoType == ANARI_INT32) {
      static const int32_t default_value[1] = {INT32_C(20)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "maximum ray recursion depth";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_minContribution_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.001000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sample contributions below this value will be neglected to speedup rendering";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_varianceThreshold_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "threshold for adaptive accumulation";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_background_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "background color and alpha (linear RGBA)";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 8;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 66:
    return ANARI_RENDERER_debug_method_info(paramType, infoName, infoType);
  case 77:
    return ANARI_RENDERER_debug_pixelSamples_info(
        paramType, infoName, infoType);
  case 63:
    return ANARI_RENDERER_debug_maxPathLength_info(
        paramType, infoName, infoType);
  case 67:
    return ANARI_RENDERER_debug_minContribution_info(
        paramType, infoName, infoType);
  case 111:
    return ANARI_RENDERER_debug_varianceThreshold_info(
        paramType, infoName, infoType);
  case 15:
    return ANARI_RENDERER_debug_background_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_world_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "world to be rendererd";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_renderer_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "renderer which renders the frame";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_camera_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera used to render the world";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_size_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "size of the frame in pixels (width, height)";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_channel_depth_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "enables mapping the color channel as the type specified";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_FRAME_name_info(paramType, infoName, infoType);
  case 126:
    return ANARI_FRAME_world_info(paramType, infoName, infoType);
  case 90:
    return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
  case 19:
    return ANARI_FRAME_camera_info(paramType, infoName, infoType);
  case 98:
    return ANARI_FRAME_size_info(paramType, infoName, infoType);
  case 21:
    return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
  case 22:
    return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of surface objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of volume objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of light objects";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GROUP_name_info(paramType, infoName, infoType);
  case 104:
    return ANARI_GROUP_surface_info(paramType, infoName, infoType);
  case 124:
    return ANARI_GROUP_volume_info(paramType, infoName, infoType);
  case 59:
    return ANARI_GROUP_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_instance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of instance objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_surface_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced surface objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_volume_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced volume objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_light_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "array of non-instanced light objects in the world";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_WORLD_name_info(paramType, infoName, infoType);
  case 48:
    return ANARI_WORLD_instance_info(paramType, infoName, infoType);
  case 104:
    return ANARI_WORLD_surface_info(paramType, infoName, infoType);
  case 124:
    return ANARI_WORLD_volume_info(paramType, infoName, infoType);
  case 59:
    return ANARI_WORLD_light_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_geometry_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "geometry object defining the surface geometry";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_material_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "material object defining the surface appearance";
    return description;
  }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_SURFACE_name_info(paramType, infoName, infoType);
  case 40:
    return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
  case 61:
    return ANARI_SURFACE_material_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_height_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "height of image plane";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 9;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
  case 78:
    return ANARI_CAMERA_orthographic_position_info(
        paramType, infoName, infoType);
  case 31:
    return ANARI_CAMERA_orthographic_direction_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
  case 43:
    return ANARI_CAMERA_orthographic_imageRegion_info(
        paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
  case 41:
    return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
  case 69:
    return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
  case 36:
    return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera position";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "main viewing direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_up_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "camera up direction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_imageRegion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "region mapped to the frame";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_fovy_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.047198f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertical field of view in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_aspect_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "aspect ratio";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_near_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "near plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_far_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "far plane clip distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 10;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
  case 78:
    return ANARI_CAMERA_perspective_position_info(
        paramType, infoName, infoType);
  case 31:
    return ANARI_CAMERA_perspective_direction_info(
        paramType, infoName, infoType);
  case 108:
    return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
  case 43:
    return ANARI_CAMERA_perspective_imageRegion_info(
        paramType, infoName, infoType);
  case 39:
    return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
  case 8:
    return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
  case 69:
    return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
  case 36:
    return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 11;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_cone_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cone_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cone_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cone_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_cone_attribute3_info(paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_cone_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cone_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cone_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cone_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cone_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_cone_vertex_position_info(
        paramType, infoName, infoType);
  case 120:
    return ANARI_GEOMETRY_cone_vertex_radius_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_cone_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_cone_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_cone_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_cone_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_cone_primitive_index_info(
        paramType, infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 12;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_curve_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_curve_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_curve_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_curve_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_curve_attribute3_info(paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_curve_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_curve_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_curve_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_curve_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_curve_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_curve_primitive_id_info(
        paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_curve_vertex_position_info(
        paramType, infoName, infoType);
  case 120:
    return ANARI_GEOMETRY_curve_vertex_radius_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_curve_vertex_color_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_curve_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_curve_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_curve_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_curve_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_curve_primitive_index_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_cap_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder cap type";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_primitive_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cylinder radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_caps_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "none";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global cylinder cap type";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "none", "first", "second", "both", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 13;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_cylinder_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_cylinder_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_cylinder_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_cylinder_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_cylinder_attribute3_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_cylinder_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_cylinder_primitive_id_info(
        paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_cylinder_vertex_position_info(
        paramType, infoName, infoType);
  case 116:
    return ANARI_GEOMETRY_cylinder_vertex_cap_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_cylinder_vertex_color_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_cylinder_primitive_index_info(
        paramType, infoName, infoType);
  case 87:
    return ANARI_GEOMETRY_cylinder_primitive_radius_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
  case 20:
    return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_isovalue_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "isovalue(s) defining the isosurface(s)";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_field_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "spatial field to be isosurfaced";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 14;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_isosurface_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_isosurface_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_isosurface_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_isosurface_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_isosurface_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_isosurface_attribute3_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_isosurface_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_isosurface_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_isosurface_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_isosurface_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_isosurface_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_isosurface_primitive_id_info(
        paramType, infoName, infoType);
  case 57:
    return ANARI_GEOMETRY_isosurface_isovalue_info(
        paramType, infoName, infoType);
  case 37:
    return ANARI_GEOMETRY_isosurface_field_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 15;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_quad_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_quad_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_quad_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_quad_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_quad_attribute3_info(paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_quad_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_quad_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_quad_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_quad_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_quad_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_quad_vertex_position_info(
        paramType, infoName, infoType);
  case 118:
    return ANARI_GEOMETRY_quad_vertex_normal_info(
        paramType, infoName, infoType);
  case 121:
    return ANARI_GEOMETRY_quad_vertex_tangent_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_quad_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_quad_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_quad_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_quad_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_quad_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sphere radius";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_radius_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "global sphere radius";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 16;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_sphere_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_sphere_attribute0_info(paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_sphere_attribute1_info(paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_sphere_attribute2_info(paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_sphere_attribute3_info(paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_sphere_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_sphere_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_sphere_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_sphere_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_sphere_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_sphere_primitive_id_info(
        paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_sphere_vertex_position_info(
        paramType, infoName, infoType);
  case 120:
    return ANARI_GEOMETRY_sphere_vertex_radius_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_sphere_vertex_color_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_sphere_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_sphere_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_sphere_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_sphere_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_sphere_primitive_index_info(
        paramType, infoName, infoType);
  case 89:
    return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute0";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute1";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute2";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "uniform attribute3";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "per primitive attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_id_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "primitive id";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex position";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_tangent_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex normal";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3,
          ANARI_FIXED16_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_FIXED16_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute0_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute0";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute1";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute2";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_vertex_attribute3_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "vertex attribute3";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_primitive_index_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index array";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {
          ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 17;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_GEOMETRY_triangle_color_info(paramType, infoName, infoType);
  case 11:
    return ANARI_GEOMETRY_triangle_attribute0_info(
        paramType, infoName, infoType);
  case 12:
    return ANARI_GEOMETRY_triangle_attribute1_info(
        paramType, infoName, infoType);
  case 13:
    return ANARI_GEOMETRY_triangle_attribute2_info(
        paramType, infoName, infoType);
  case 14:
    return ANARI_GEOMETRY_triangle_attribute3_info(
        paramType, infoName, infoType);
  case 84:
    return ANARI_GEOMETRY_triangle_primitive_color_info(
        paramType, infoName, infoType);
  case 80:
    return ANARI_GEOMETRY_triangle_primitive_attribute0_info(
        paramType, infoName, infoType);
  case 81:
    return ANARI_GEOMETRY_triangle_primitive_attribute1_info(
        paramType, infoName, infoType);
  case 82:
    return ANARI_GEOMETRY_triangle_primitive_attribute2_info(
        paramType, infoName, infoType);
  case 83:
    return ANARI_GEOMETRY_triangle_primitive_attribute3_info(
        paramType, infoName, infoType);
  case 85:
    return ANARI_GEOMETRY_triangle_primitive_id_info(
        paramType, infoName, infoType);
  case 119:
    return ANARI_GEOMETRY_triangle_vertex_position_info(
        paramType, infoName, infoType);
  case 118:
    return ANARI_GEOMETRY_triangle_vertex_normal_info(
        paramType, infoName, infoType);
  case 121:
    return ANARI_GEOMETRY_triangle_vertex_tangent_info(
        paramType, infoName, infoType);
  case 117:
    return ANARI_GEOMETRY_triangle_vertex_color_info(
        paramType, infoName, infoType);
  case 112:
    return ANARI_GEOMETRY_triangle_vertex_attribute0_info(
        paramType, infoName, infoType);
  case 113:
    return ANARI_GEOMETRY_triangle_vertex_attribute1_info(
        paramType, infoName, infoType);
  case 114:
    return ANARI_GEOMETRY_triangle_vertex_attribute2_info(
        paramType, infoName, infoType);
  case 115:
    return ANARI_GEOMETRY_triangle_vertex_attribute3_info(
        paramType, infoName, infoType);
  case 86:
    return ANARI_GEOMETRY_triangle_primitive_index_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 2: // minimum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 3: // maximum
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "color of the light";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_position_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "point";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "position of the light source";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_direction_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "direction";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "the axis of the spot";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_openingAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {3.141593f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opening angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_falloffAngle_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.100000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "falloff angle in radians";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_intensity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light emitted in a direction in W/sr";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_power_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "overall amount of light energy emitted in W";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 18;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_visible_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
      static const int8_t default_value[1] = {INT8_C(1)};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "visibility of the light geometry";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_AREA_LIGHTS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 19;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
  case 78:
    return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
  case 31:
    return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
  case 73:
    return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
  case 35:
    return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
  case 49:
    return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
  case 79:
    return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
  case 122:
    return ANARI_LIGHT_spot_visible_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "diffuse color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 20;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
  case 26:
    return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
  case 72:
    return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_baseColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "base color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "opacity";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_metallic_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "metallic factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_roughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "roughness factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_normal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_emissive_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "emissive factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_occlusion_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "precomputed occlusion";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaMode_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "opaque";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "alpha mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"opaque", "blend", "mask", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "cutoff for alpha mask mode";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specular_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_specularColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "specular color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoat_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "clearcoat normal map";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_transmission_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transmission factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_ior_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.500000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "index of refraction";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_thickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wall thickness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {INFINITY};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation distance";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_attenuationColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "attenuation color";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenColor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 11: // use
    if (infoType == ANARI_STRING) {
      return "color";
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen color";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sheen roughness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescence_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence factor";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.300000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence index of refraction";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "iridescence thicknness";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 21;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_MATERIAL_physicallyBased_name_info(
        paramType, infoName, infoType);
  case 17:
    return ANARI_MATERIAL_physicallyBased_baseColor_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_MATERIAL_physicallyBased_opacity_info(
        paramType, infoName, infoType);
  case 65:
    return ANARI_MATERIAL_physicallyBased_metallic_info(
        paramType, infoName, infoType);
  case 91:
    return ANARI_MATERIAL_physicallyBased_roughness_info(
        paramType, infoName, infoType);
  case 70:
    return ANARI_MATERIAL_physicallyBased_normal_info(
        paramType, infoName, infoType);
  case 34:
    return ANARI_MATERIAL_physicallyBased_emissive_info(
        paramType, infoName, infoType);
  case 71:
    return ANARI_MATERIAL_physicallyBased_occlusion_info(
        paramType, infoName, infoType);
  case 2:
    return ANARI_MATERIAL_physicallyBased_alphaMode_info(
        paramType, infoName, infoType);
  case 1:
    return ANARI_MATERIAL_physicallyBased_alphaCutoff_info(
        paramType, infoName, infoType);
  case 100:
    return ANARI_MATERIAL_physicallyBased_specular_info(
        paramType, infoName, infoType);
  case 101:
    return ANARI_MATERIAL_physicallyBased_specularColor_info(
        paramType, infoName, infoType);
  case 23:
    return ANARI_MATERIAL_physicallyBased_clearcoat_info(
        paramType, infoName, infoType);
  case 25:
    return ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(
        paramType, infoName, infoType);
  case 24:
    return ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(
        paramType, infoName, infoType);
  case 106:
    return ANARI_MATERIAL_physicallyBased_transmission_info(
        paramType, infoName, infoType);
  case 52:
    return ANARI_MATERIAL_physicallyBased_ior_info(
        paramType, infoName, infoType);
  case 105:
    return ANARI_MATERIAL_physicallyBased_thickness_info(
        paramType, infoName, infoType);
  case 10:
    return ANARI_MATERIAL_physicallyBased_attenuationDistance_info(
        paramType, infoName, infoType);
  case 9:
    return ANARI_MATERIAL_physicallyBased_attenuationColor_info(
        paramType, infoName, infoType);
  case 95:
    return ANARI_MATERIAL_physicallyBased_sheenColor_info(
        paramType, infoName, infoType);
  case 96:
    return ANARI_MATERIAL_physicallyBased_sheenRoughness_info(
        paramType, infoName, infoType);
  case 53:
    return ANARI_MATERIAL_physicallyBased_iridescence_info(
        paramType, infoName, infoType);
  case 54:
    return ANARI_MATERIAL_physicallyBased_iridescenceIor_info(
        paramType, infoName, infoType);
  case 55:
    return ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 22;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
  case 42:
    return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
  case 44:
    return ANARI_SAMPLER_image1D_inAttribute_info(
        paramType, infoName, infoType);
  case 38:
    return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
  case 127:
    return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
  case 46:
    return ANARI_SAMPLER_image1D_inTransform_info(
        paramType, infoName, infoType);
  case 45:
    return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
  case 76:
    return ANARI_SAMPLER_image1D_outTransform_info(
        paramType, infoName, infoType);
  case 75:
    return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_image_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array backing the sampler";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inAttribute_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "attribute0";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "input surface attribute (texture coordinate)";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"color",
          "worldPosition",
          "worldNormal",
          "objectPosition",
          "objectNormal",
          "attribute0",
          "attribute1",
          "attribute2",
          "attribute3",
          "primitiveId",
          nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "nearest";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode1_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 1st dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_wrapMode2_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "clampToEdge";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "wrap mode for the 2nd dimension";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {
          "clampToEdge", "repeat", "mirrorRepeat", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "transform applied to the input attribute before sampling";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_inOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output inTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outTransform_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
      static const float default_value[16] = {1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          0.000000f,
          1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "transform applied to the sampled values";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_outOffset_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
      static const float default_value[4] = {
          0.000000f, 0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "offset added to output outTransform result";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 23;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_param_info(const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
  case 42:
    return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
  case 44:
    return ANARI_SAMPLER_image2D_inAttribute_info(
        paramType, infoName, infoType);
  case 38:
    return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
  case 127:
    return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
  case 128:
    return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
  case 46:
    return ANARI_SAMPLER_image2D_inTransform_info(
        paramType, infoName, infoType);
  case 45:
    return ANARI_SAMPLER_image2D_inOffset_info(paramType, infoName, infoType);
  case 76:
    return ANARI_SAMPLER_image2D_outTransform_info(
        paramType, infoName, infoType);
  case 75:
    return ANARI_SAMPLER_image2D_outOffset_info(paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_data_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "array of vertex centered scalar values";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UINT8,
          ANARI_INT16,
          ANARI_UINT16,
          ANARI_FLOAT32,
          ANARI_FLOAT64,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "origin of the grid in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
      static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "size of the grid cells in object-space";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_STRING && infoType == ANARI_STRING) {
      static const char *default_value = "linear";
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "filter mode used to interpolate the grid";
    return description;
  }
  case 6: // value
    if (paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
      static const char *values[] = {"nearest", "linear", nullptr};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 24;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_SPATIAL_FIELD_structuredRegular_name_info(
        paramType, infoName, infoType);
  case 27:
    return ANARI_SPATIAL_FIELD_structuredRegular_data_info(
        paramType, infoName, infoType);
  case 74:
    return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(
        paramType, infoName, infoType);
  case 99:
    return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(
        paramType, infoName, infoType);
  case 38:
    return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_name_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "optional object name";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_value_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "spatial field used for the field values of the volume";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_valueRange_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
      static const float default_value[2] = {0.000000f, 1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "sampled values of field are clamped to this range";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_color_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled color";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_UFIXED8,
          ANARI_UFIXED8_VEC2,
          ANARI_UFIXED8_VEC3,
          ANARI_UFIXED8_VEC4,
          ANARI_UFIXED8_R_SRGB,
          ANARI_UFIXED8_RA_SRGB,
          ANARI_UFIXED8_RGB_SRGB,
          ANARI_UFIXED8_RGBA_SRGB,
          ANARI_UFIXED16,
          ANARI_UFIXED16_VEC2,
          ANARI_UFIXED16_VEC3,
          ANARI_UFIXED16_VEC4,
          ANARI_UFIXED32,
          ANARI_UFIXED32_VEC2,
          ANARI_UFIXED32_VEC3,
          ANARI_UFIXED32_VEC4,
          ANARI_FLOAT32,
          ANARI_FLOAT32_VEC2,
          ANARI_FLOAT32_VEC3,
          ANARI_FLOAT32_VEC4,
          ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_opacity_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_true;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description = "sampled opacity";
    return description;
  }
  case 5: // elementType
    if (infoType == ANARI_DATA_TYPE_LIST) {
      static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
      return values;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_unitDistance_info(
    ANARIDataType paramType, int infoName, ANARIDataType infoType)
{
  (void)paramType;
  switch (infoName) {
  case 0: // required
    if (infoType == ANARI_BOOL) {
      return &anari_false;
    } else {
      return nullptr;
    }
  case 1: // default
    if (paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
      static const float default_value[1] = {1.000000f};
      return default_value;
    } else {
      return nullptr;
    }
  case 4: // description
  {
    static const char *description =
        "makes volumes uniformly thinner or thicker";
    return description;
  }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int32_t value = 25;
      return &value;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_param_info(
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (param_hash(paramName)) {
  case 68:
    return ANARI_VOLUME_transferFunction1D_name_info(
        paramType, infoName, infoType);
  case 109:
    return ANARI_VOLUME_transferFunction1D_value_info(
        paramType, infoName, infoType);
  case 110:
    return ANARI_VOLUME_transferFunction1D_valueRange_info(
        paramType, infoName, infoType);
  case 26:
    return ANARI_VOLUME_transferFunction1D_color_info(
        paramType, infoName, infoType);
  case 72:
    return ANARI_VOLUME_transferFunction1D_opacity_info(
        paramType, infoName, infoType);
  case 107:
    return ANARI_VOLUME_transferFunction1D_unitDistance_info(
        paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 11:
    return ANARI_CAMERA_orthographic_param_info(
        paramName, paramType, infoName, infoType);
  case 13:
    return ANARI_CAMERA_perspective_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_param_info(
        paramName, paramType, infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_param_info(
        paramName, paramType, infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_param_info(
        paramName, paramType, infoName, infoType);
  case 9:
    return ANARI_GEOMETRY_isosurface_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_sphere_param_info(
        paramName, paramType, infoName, infoType);
  case 23:
    return ANARI_GEOMETRY_triangle_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_param_info(
        paramName, paramType, infoName, infoType);
  case 15:
    return ANARI_LIGHT_point_param_info(
        paramName, paramType, infoName, infoType);
  case 17:
    return ANARI_LIGHT_ring_param_info(
        paramName, paramType, infoName, infoType);
  case 16:
    return ANARI_LIGHT_quad_param_info(
        paramName, paramType, infoName, infoType);
  case 6:
    return ANARI_LIGHT_hdri_param_info(
        paramName, paramType, infoName, infoType);
  case 20:
    return ANARI_LIGHT_spot_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 10:
    return ANARI_MATERIAL_matte_param_info(
        paramName, paramType, infoName, infoType);
  case 14:
    return ANARI_MATERIAL_physicallyBased_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_param_info(
        paramName, paramType, infoName, infoType);
  case 12:
    return ANARI_RENDERER_pathtracer_param_info(
        paramName, paramType, infoName, infoType);
  case 18:
    return ANARI_RENDERER_scivis_param_info(
        paramName, paramType, infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 7:
    return ANARI_SAMPLER_image1D_param_info(
        paramName, paramType, infoName, infoType);
  case 8:
    return ANARI_SAMPLER_image2D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 21:
    return ANARI_SPATIAL_FIELD_structuredRegular_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_param_info(const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 22:
    return ANARI_VOLUME_transferFunction1D_param_info(
        paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info_enum(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_param_info(
        subtype, paramName, paramType, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_param_info(ANARIDataType type,
    const char *subtype,
    const char *paramName,
    ANARIDataType paramType,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_param_info_enum(
      type, subtype, paramName, paramType, infoName, infoType);
}
static const void *ANARI_DEVICE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "device object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"allowInvalidMaterials", ANARI_BOOL},
          {"invalidMaterialColor", ANARI_FLOAT32_VEC4},
          {"name", ANARI_STRING},
          {"statusCallback", ANARI_STATUS_CALLBACK},
          {"statusCallbackUserData", ANARI_VOID_POINTER},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_directional_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "directional light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"irradiance", ANARI_FLOAT32},
          {"direction", ANARI_FLOAT32_VEC3},
          {"angularDiameter", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_DIRECTIONAL";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 0;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "point light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radius", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_POINT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 1;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_ring_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "ring light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radius", ANARI_FLOAT32},
          {"innerRadius", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"intensityDistribution", ANARI_ARRAY1D},
          {"intensityDistribution", ANARI_ARRAY2D},
          {"c0", ANARI_FLOAT32_VEC3},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_RING";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 2;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_quad_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"edge1", ANARI_FLOAT32_VEC3},
          {"edge2", ANARI_FLOAT32_VEC3},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"radiance", ANARI_FLOAT32},
          {"side", ANARI_STRING},
          {"intensityDistribution", ANARI_ARRAY1D},
          {"intensityDistribution", ANARI_ARRAY2D},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 3;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_hdri_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "hdri light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"radiance", ANARI_ARRAY2D},
          {"layout", ANARI_STRING},
          {"scale", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_HDRI";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 4;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_default_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {"denoise", ANARI_BOOL},
          {"denoiseAlpha", ANARI_BOOL},
          {"denoiseQuality", ANARI_STRING},
          {"name", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEFAULT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 5;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_pathtracer_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The path tracer supports soft shadows, indirect illumination and realistic materials.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"lightSamples", ANARI_INT32},
          {"roulettePathLength", ANARI_INT32},
          {"maxScatteringEvents", ANARI_INT32},
          {"maxContribution", ANARI_FLOAT32},
          {"backgroundRefraction", ANARI_BOOL},
          {"denoise", ANARI_BOOL},
          {"denoiseAlpha", ANARI_BOOL},
          {"denoiseQuality", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_PATHTRACER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 6;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_scivis_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "The SciVis renderer is a fast ray tracer for scientific visualization which supports volume rendering and ambient occlusion (AO).";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {"shadows", ANARI_BOOL},
          {"ambientColor", ANARI_FLOAT32_VEC3},
          {"ambientRadiance", ANARI_FLOAT32},
          {"aoSamples", ANARI_INT32},
          {"aoDistance", ANARI_FLOAT32},
          {"volumeSamplingRate", ANARI_FLOAT32},
          {"visibleLights", ANARI_BOOL},
          {"denoise", ANARI_BOOL},
          {"denoiseAlpha", ANARI_BOOL},
          {"denoiseQuality", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_SCIVIS";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 7;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_debug_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description =
        "This renderer is used for debugging the underlying OSPRay system.";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"method", ANARI_STRING},
          {"pixelSamples", ANARI_INT32},
          {"maxPathLength", ANARI_INT32},
          {"minContribution", ANARI_FLOAT32},
          {"varianceThreshold", ANARI_FLOAT32},
          {"background", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "OSPRAY_RENDERER_DEBUG";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 8;
      return &value;
    } else {
      return nullptr;
    }
  case 8: // extension
    if (infoType == ANARI_STRING_LIST) {
      static const char *extensions[] = {"ANARI_KHR_LIGHT_DIRECTIONAL",
          "ANARI_KHR_LIGHT_POINT",
          "ANARI_KHR_LIGHT_RING",
          "ANARI_KHR_LIGHT_QUAD",
          "ANARI_KHR_LIGHT_HDRI",
          "ANARI_OSPRAY_RENDERER_DEFAULT",
          "ANARI_OSPRAY_RENDERER_PATHTRACER",
          "ANARI_OSPRAY_RENDERER_SCIVIS",
          "ANARI_OSPRAY_RENDERER_DEBUG",
          "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
          "ANARI_KHR_CAMERA_PERSPECTIVE",
          "ANARI_KHR_GEOMETRY_CONE",
          "ANARI_KHR_GEOMETRY_CURVE",
          "ANARI_KHR_GEOMETRY_CYLINDER",
          "ANARI_KHR_GEOMETRY_ISOSURFACE",
          "ANARI_KHR_GEOMETRY_QUAD",
          "ANARI_KHR_GEOMETRY_SPHERE",
          "ANARI_KHR_GEOMETRY_TRIANGLE",
          "ANARI_KHR_LIGHT_SPOT",
          "ANARI_KHR_AREA_LIGHTS",
          "ANARI_KHR_MATERIAL_MATTE",
          "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
          "ANARI_KHR_SAMPLER_IMAGE1D",
          "ANARI_KHR_SAMPLER_IMAGE2D",
          "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
          "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
          "ANARI_OSPRAY_EXTENSIONS",
          0};
      return extensions;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "one dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "two dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "three dimensional array object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {
          {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_FRAME_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "frame object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"world", ANARI_WORLD},
          {"renderer", ANARI_RENDERER},
          {"camera", ANARI_CAMERA},
          {"size", ANARI_UINT32_VEC2},
          {"channel.color", ANARI_DATA_TYPE},
          {"channel.depth", ANARI_DATA_TYPE},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 10: // channel
    if (infoType == ANARI_STRING_LIST) {
      static const char *channel[] = {"channel.color", "channel.depth", 0};
      return channel;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GROUP_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "group object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_WORLD_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "world object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"instance", ANARI_ARRAY1D},
          {"surface", ANARI_ARRAY1D},
          {"volume", ANARI_ARRAY1D},
          {"light", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SURFACE_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "surface object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"geometry", ANARI_GEOMETRY},
          {"material", ANARI_MATERIAL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_orthographic_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "orthographic camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"aspect", ANARI_FLOAT32},
          {"height", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 9;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_perspective_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "perspective camera object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"up", ANARI_FLOAT32_VEC3},
          {"imageRegion", ANARI_FLOAT32_BOX2},
          {"fovy", ANARI_FLOAT32},
          {"aspect", ANARI_FLOAT32},
          {"near", ANARI_FLOAT32},
          {"far", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_CAMERA_PERSPECTIVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 10;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cone_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cone geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CONE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 11;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_curve_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "curve geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CURVE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 12;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_cylinder_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "cylinder geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.cap", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"primitive.radius", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {"caps", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_CYLINDER";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 13;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_isosurface_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "isosurface geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"isovalue", ANARI_FLOAT32},
          {"isovalue", ANARI_ARRAY1D},
          {"field", ANARI_SPATIAL_FIELD},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_ISOSURFACE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 14;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_quad_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "quad geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_QUAD";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 15;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_sphere_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "sphere geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.radius", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {"radius", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_SPHERE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 16;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_triangle_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "triangle geometry object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC4},
          {"attribute0", ANARI_FLOAT32_VEC4},
          {"attribute1", ANARI_FLOAT32_VEC4},
          {"attribute2", ANARI_FLOAT32_VEC4},
          {"attribute3", ANARI_FLOAT32_VEC4},
          {"primitive.color", ANARI_ARRAY1D},
          {"primitive.attribute0", ANARI_ARRAY1D},
          {"primitive.attribute1", ANARI_ARRAY1D},
          {"primitive.attribute2", ANARI_ARRAY1D},
          {"primitive.attribute3", ANARI_ARRAY1D},
          {"primitive.id", ANARI_ARRAY1D},
          {"vertex.position", ANARI_ARRAY1D},
          {"vertex.normal", ANARI_ARRAY1D},
          {"vertex.tangent", ANARI_ARRAY1D},
          {"vertex.color", ANARI_ARRAY1D},
          {"vertex.attribute0", ANARI_ARRAY1D},
          {"vertex.attribute1", ANARI_ARRAY1D},
          {"vertex.attribute2", ANARI_ARRAY1D},
          {"vertex.attribute3", ANARI_ARRAY1D},
          {"primitive.index", ANARI_ARRAY1D},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_GEOMETRY_TRIANGLE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 17;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "spot light object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"position", ANARI_FLOAT32_VEC3},
          {"direction", ANARI_FLOAT32_VEC3},
          {"openingAngle", ANARI_FLOAT32},
          {"falloffAngle", ANARI_FLOAT32},
          {"intensity", ANARI_FLOAT32},
          {"power", ANARI_FLOAT32},
          {"visible", ANARI_BOOL},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_LIGHT_SPOT";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 18;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_matte_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "matte material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_SAMPLER},
          {"color", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_MATTE";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 20;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_physicallyBased_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "physically based material object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"baseColor", ANARI_FLOAT32_VEC3},
          {"baseColor", ANARI_SAMPLER},
          {"baseColor", ANARI_STRING},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_SAMPLER},
          {"opacity", ANARI_STRING},
          {"metallic", ANARI_FLOAT32},
          {"metallic", ANARI_SAMPLER},
          {"metallic", ANARI_STRING},
          {"roughness", ANARI_FLOAT32},
          {"roughness", ANARI_SAMPLER},
          {"roughness", ANARI_STRING},
          {"normal", ANARI_SAMPLER},
          {"emissive", ANARI_FLOAT32_VEC3},
          {"emissive", ANARI_SAMPLER},
          {"emissive", ANARI_STRING},
          {"occlusion", ANARI_SAMPLER},
          {"alphaMode", ANARI_STRING},
          {"alphaCutoff", ANARI_FLOAT32},
          {"specular", ANARI_FLOAT32},
          {"specular", ANARI_SAMPLER},
          {"specular", ANARI_STRING},
          {"specularColor", ANARI_FLOAT32_VEC3},
          {"specularColor", ANARI_SAMPLER},
          {"specularColor", ANARI_STRING},
          {"clearcoat", ANARI_FLOAT32},
          {"clearcoat", ANARI_SAMPLER},
          {"clearcoat", ANARI_STRING},
          {"clearcoatRoughness", ANARI_FLOAT32},
          {"clearcoatRoughness", ANARI_SAMPLER},
          {"clearcoatRoughness", ANARI_STRING},
          {"clearcoatNormal", ANARI_SAMPLER},
          {"transmission", ANARI_FLOAT32},
          {"transmission", ANARI_SAMPLER},
          {"transmission", ANARI_STRING},
          {"ior", ANARI_FLOAT32},
          {"ior", ANARI_SAMPLER},
          {"ior", ANARI_STRING},
          {"thickness", ANARI_FLOAT32},
          {"thickness", ANARI_SAMPLER},
          {"thickness", ANARI_STRING},
          {"attenuationDistance", ANARI_FLOAT32},
          {"attenuationColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_FLOAT32_VEC3},
          {"sheenColor", ANARI_SAMPLER},
          {"sheenColor", ANARI_STRING},
          {"sheenRoughness", ANARI_FLOAT32},
          {"sheenRoughness", ANARI_SAMPLER},
          {"sheenRoughness", ANARI_STRING},
          {"iridescence", ANARI_FLOAT32},
          {"iridescence", ANARI_SAMPLER},
          {"iridescence", ANARI_STRING},
          {"iridescenceIor", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_FLOAT32},
          {"iridescenceThickness", ANARI_SAMPLER},
          {"iridescenceThickness", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 21;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image1D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY1D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 22;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_image2D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "image2D object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"image", ANARI_ARRAY2D},
          {"inAttribute", ANARI_STRING},
          {"filter", ANARI_STRING},
          {"wrapMode1", ANARI_STRING},
          {"wrapMode2", ANARI_STRING},
          {"inTransform", ANARI_FLOAT32_MAT4},
          {"inOffset", ANARI_FLOAT32_VEC4},
          {"outTransform", ANARI_FLOAT32_MAT4},
          {"outOffset", ANARI_FLOAT32_VEC4},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SAMPLER_IMAGE2D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 23;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_structuredRegular_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "structured regular spatial field object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"data", ANARI_ARRAY3D},
          {"origin", ANARI_FLOAT32_VEC3},
          {"spacing", ANARI_FLOAT32_VEC3},
          {"filter", ANARI_STRING},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 24;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_transferFunction1D_info(
    int infoName, ANARIDataType infoType)
{
  switch (infoName) {
  case 4: // description
  {
    static const char *description = "transferFunction1D volume object";
    return description;
  }
  case 9: // parameter
    if (infoType == ANARI_PARAMETER_LIST) {
      static const ANARIParameter parameters[] = {{"name", ANARI_STRING},
          {"value", ANARI_SPATIAL_FIELD},
          {"valueRange", ANARI_FLOAT32_BOX1},
          {"valueRange", ANARI_FLOAT64_BOX1},
          {"color", ANARI_FLOAT32_VEC4},
          {"color", ANARI_FLOAT32_VEC3},
          {"color", ANARI_ARRAY1D},
          {"opacity", ANARI_FLOAT32},
          {"opacity", ANARI_ARRAY1D},
          {"unitDistance", ANARI_FLOAT32},
          {0, ANARI_UNKNOWN}};
      return parameters;
    } else {
      return nullptr;
    }
  case 7: // sourceExtension
    if (infoType == ANARI_STRING) {
      static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
      return extension;
    } else if (infoType == ANARI_INT32) {
      static const int value = 25;
      return &value;
    } else {
      return nullptr;
    }
  default:
    return nullptr;
  }
}
static const void *ANARI_CAMERA_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 11:
    return ANARI_CAMERA_orthographic_info(infoName, infoType);
  case 13:
    return ANARI_CAMERA_perspective_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_GEOMETRY_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 0:
    return ANARI_GEOMETRY_cone_info(infoName, infoType);
  case 1:
    return ANARI_GEOMETRY_curve_info(infoName, infoType);
  case 2:
    return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
  case 9:
    return ANARI_GEOMETRY_isosurface_info(infoName, infoType);
  case 16:
    return ANARI_GEOMETRY_quad_info(infoName, infoType);
  case 19:
    return ANARI_GEOMETRY_sphere_info(infoName, infoType);
  case 23:
    return ANARI_GEOMETRY_triangle_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_LIGHT_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 5:
    return ANARI_LIGHT_directional_info(infoName, infoType);
  case 15:
    return ANARI_LIGHT_point_info(infoName, infoType);
  case 17:
    return ANARI_LIGHT_ring_info(infoName, infoType);
  case 16:
    return ANARI_LIGHT_quad_info(infoName, infoType);
  case 6:
    return ANARI_LIGHT_hdri_info(infoName, infoType);
  case 20:
    return ANARI_LIGHT_spot_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_MATERIAL_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 10:
    return ANARI_MATERIAL_matte_info(infoName, infoType);
  case 14:
    return ANARI_MATERIAL_physicallyBased_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_RENDERER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 4:
    return ANARI_RENDERER_default_info(infoName, infoType);
  case 12:
    return ANARI_RENDERER_pathtracer_info(infoName, infoType);
  case 18:
    return ANARI_RENDERER_scivis_info(infoName, infoType);
  case 3:
    return ANARI_RENDERER_debug_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SAMPLER_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 7:
    return ANARI_SAMPLER_image1D_info(infoName, infoType);
  case 8:
    return ANARI_SAMPLER_image2D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_SPATIAL_FIELD_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 21:
    return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
  default:
    return nullptr;
  }
}
static const void *ANARI_VOLUME_info(
    const char *subtype, int infoName, ANARIDataType infoType)
{
  switch (subtype_hash(subtype)) {
  case 22:
    return ANARI_VOLUME_transferFunction1D_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info_enum(ANARIDataType type,
    const char *subtype,
    int infoName,
    ANARIDataType infoType)
{
  switch (type) {
  case ANARI_CAMERA:
    return ANARI_CAMERA_info(subtype, infoName, infoType);
  case ANARI_GEOMETRY:
    return ANARI_GEOMETRY_info(subtype, infoName, infoType);
  case ANARI_LIGHT:
    return ANARI_LIGHT_info(subtype, infoName, infoType);
  case ANARI_MATERIAL:
    return ANARI_MATERIAL_info(subtype, infoName, infoType);
  case ANARI_RENDERER:
    return ANARI_RENDERER_info(subtype, infoName, infoType);
  case ANARI_SAMPLER:
    return ANARI_SAMPLER_info(subtype, infoName, infoType);
  case ANARI_SPATIAL_FIELD:
    return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
  case ANARI_VOLUME:
    return ANARI_VOLUME_info(subtype, infoName, infoType);
  case ANARI_DEVICE:
    return ANARI_DEVICE_info(infoName, infoType);
  case ANARI_ARRAY1D:
    return ANARI_ARRAY1D_info(infoName, infoType);
  case ANARI_ARRAY2D:
    return ANARI_ARRAY2D_info(infoName, infoType);
  case ANARI_ARRAY3D:
    return ANARI_ARRAY3D_info(infoName, infoType);
  case ANARI_FRAME:
    return ANARI_FRAME_info(infoName, infoType);
  case ANARI_GROUP:
    return ANARI_GROUP_info(infoName, infoType);
  case ANARI_WORLD:
    return ANARI_WORLD_info(infoName, infoType);
  case ANARI_SURFACE:
    return ANARI_SURFACE_info(infoName, infoType);
  default:
    return nullptr;
  }
}
const void *query_object_info(ANARIDataType type,
    const char *subtype,
    const char *infoNameString,
    ANARIDataType infoType)
{
  int infoName = info_hash(infoNameString);
  return query_object_info_enum(type, subtype, infoName, infoType);
}
} // namespace anari_ospray
